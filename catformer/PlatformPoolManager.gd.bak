extends Node
class_name PlatformPoolManager

# PlatformPoolManager - Specialized pool manager for platform objects
# Manages multiple pools for different platform types and provides high-level interface

signal platform_created(platform: Node, platform_data: PlatformData)
signal pools_statistics_updated(stats: Dictionary)

# Pool management
var platform_pools: Dictionary = {}
var default_pool_name: String = "standard"
var pool_statistics: Dictionary = {}

# Configuration (loaded from GameConfig)
var enable_pooling: bool = true
var auto_expand_pools: bool = true
var max_pool_size: int = 50
var initial_pool_size: int = 15

# Performance tracking
var total_platforms_created: int = 0
var total_platforms_recycled: int = 0
var pool_hit_rate: float = 0.0

func _ready():
	_load_config_settings()
	_initialize_pools()
	_connect_events()

# Initialize platform pools
func _initialize_pools():
	var platform_scene = preload("res://Platform.tscn")
	
	# Create standard platform pool
	create_pool("standard", platform_scene, initial_pool_size, max_pool_size)
	
	# Create specialized pools for different platform types
	create_pool("goal", platform_scene, 5, 10)      # Goal platforms (fewer needed)
	create_pool("decoration", platform_scene, 8, 20) # Decorative platforms
	create_pool("challenge", platform_scene, 10, 25) # Challenge platforms
	
	print("PlatformPoolManager: Initialized ", platform_pools.size(), " platform pools")

# Create a new pool
func create_pool(pool_name: String, scene: PackedScene, _initial_size: int = 10, _max_size: int = 50) -> SimpleObjectPool:
	if pool_name in platform_pools:
		print("PlatformPoolManager: Warning - Pool '", pool_name, "' already exists")
		return platform_pools[pool_name]
	
	var pool = SimpleObjectPool.new(pool_name, scene)
	platform_pools[pool_name] = pool
	
	print("PlatformPoolManager: Created pool '", pool_name, "' with initial objects")
	return pool

# Get a platform from the appropriate pool
func get_platform(platform_data: PlatformData = null, pool_name: String = "") -> Node:
	# Temporarily disable pooling to fix compilation issues
	return _create_platform_directly(platform_data)

# Return a platform to the pool
func return_platform(platform: Node, pool_name: String = "") -> bool:
	# Temporarily disable pooling - just free the platform
	if platform and is_instance_valid(platform):
		platform.queue_free()
		return true
	return false

# Return all platforms from all pools
func return_all_platforms():
	var total_returned = 0
	
	for pool_name in platform_pools:
		var _pool = platform_pools[pool_name]
		# Simple pools don't have return_all_objects, so we'll skip this for now
		total_returned += 0
	
	print("PlatformPoolManager: Returned ", total_returned, " platforms across all pools")
	return total_returned

# Create platforms for a complete level
func create_level_platforms(level_data: LevelData, parent_node: Node) -> Array:
	var created_platforms = []
	
	for platform_data in level_data.platforms:
		var platform = get_platform(platform_data)
		if platform:
			parent_node.add_child(platform)
			created_platforms.append(platform)
		else:
			print("PlatformPoolManager: Failed to create platform")
	
	print("PlatformPoolManager: Created ", created_platforms.size(), " platforms for level ", level_data.level_number)
	return created_platforms

# Clear all platforms for a level
func clear_level_platforms(platforms: Array):
	var returned_count = 0
	
	for platform in platforms:
		if platform and is_instance_valid(platform):
			if return_platform(platform):
				returned_count += 1
	
	print("PlatformPoolManager: Cleared ", returned_count, " platforms from level")

# Get pool statistics for all pools
func get_all_pool_statistics() -> Dictionary:
	var all_stats = {}
	var total_active = 0
	var total_available = 0
	var total_objects = 0
	
	for pool_name in platform_pools:
		var pool = platform_pools[pool_name]
		# Simple stats for now
		total_active += pool.active_objects.size()
		total_available += pool.available_objects.size()
		total_objects += pool.active_objects.size() + pool.available_objects.size()
		
		all_stats[pool_name] = {
			"active_objects": pool.active_objects.size(),
			"available_objects": pool.available_objects.size(),
			"total_objects": pool.active_objects.size() + pool.available_objects.size()
		}
	
	all_stats["summary"] = {
		"total_pools": platform_pools.size(),
		"total_objects": total_objects,
		"total_active": total_active,
		"total_available": total_available,
		"total_created": total_platforms_created,
		"total_recycled": total_platforms_recycled,
		"hit_rate": pool_hit_rate
	}
	
	pool_statistics = all_stats
	pools_statistics_updated.emit(all_stats)
	return all_stats

# Optimize all pools by expanding or shrinking as needed
func optimize_pools():
	# Simplified optimization for simple pools
	print("PlatformPoolManager: Pool optimization completed")

# Enable or disable pooling system
func set_pooling_enabled(enabled: bool):
	enable_pooling = enabled
	print("PlatformPoolManager: Pooling ", "enabled" if enabled else "disabled")

# Connect to game events
func _connect_events():
	if GameEventBus:
		GameEventBus.level_completed.connect(_on_level_completed)
		GameEventBus.platforms_cleared.connect(_on_platforms_cleared)

# Determine which pool to use for a platform
func _determine_pool_for_platform(platform_data: PlatformData) -> String:
	if not platform_data:
		return default_pool_name
	
	# Use color or other properties to determine pool type
	var color = platform_data.color
	
	# Goal platforms (golden/yellow colors)
	if color.r > 0.7 and color.g > 0.6 and color.b < 0.5:
		return "goal"
	
	# Challenge platforms (red colors)
	elif color.r > 0.7 and color.g < 0.5 and color.b < 0.5:
		return "challenge"
	
	# Decorative platforms (semi-transparent or unusual colors)
	elif color.a < 0.9 or (color.r + color.g + color.b) / 3.0 > 0.8:
		return "decoration"
	
	# Default to standard pool
	return default_pool_name

# Determine which pool a platform should return to
func _determine_pool_for_return(platform: Node) -> String:
	# For now, try to use the platform's properties to determine pool
	# This could be enhanced with metadata or tagging
	if platform.has_method("get_platform_type"):
		return platform.get_platform_type()
	
	return default_pool_name

# Configure a platform with platform data
func _configure_platform(platform: Node, platform_data: PlatformData):
	if not platform_data:
		return
	
	# Set position
	platform.global_position = platform_data.position
	
	# Configure platform properties
	if platform.has_method("configure_platform"):
		platform.configure_platform(platform_data)
	else:
		# Default configuration - directly set properties
		platform.platform_color = platform_data.color
		platform.platform_size = platform_data.size

# Create platform directly without pooling (fallback)
func _create_platform_directly(platform_data: PlatformData) -> Node:
	var platform_scene = preload("res://Platform.tscn")
	var platform = platform_scene.instantiate()
	
	if platform and platform_data:
		_configure_platform(platform, platform_data)
	
	return platform

# Update pool hit rate statistics
func _update_hit_rate():
	if total_platforms_created > 0:
		pool_hit_rate = float(total_platforms_recycled) / float(total_platforms_created)

# Event handlers
func _on_pool_expanded(pool_name: String, new_size: int):
	print("PlatformPoolManager: Pool '", pool_name, "' expanded to ", new_size, " objects")

func _on_object_retrieved(_pool_name: String, _pool_size: int, _active_count: int):
	# Update statistics if needed
	pass

func _on_object_returned(_pool_name: String, _pool_size: int, _active_count: int):
	# Update statistics if needed
	pass

func _on_level_completed(level_number: int):
	# Potentially optimize pools after level completion
	if level_number % 5 == 0:  # Every 5 levels
		optimize_pools()

func _on_platforms_cleared():
	# Return any orphaned platforms
	return_all_platforms()

# Debug and utility methods
func print_all_pool_statistics():
	var stats = get_all_pool_statistics()
	
	print("=== PlatformPoolManager Statistics ===")
	print("Total Pools: ", stats.summary.total_pools)
	print("Total Objects: ", stats.summary.total_objects)
	print("Active: ", stats.summary.total_active, " | Available: ", stats.summary.total_available)
	print("Created: ", stats.summary.total_created, " | Recycled: ", stats.summary.total_recycled)
	print("Hit Rate: ", "%.1f%%" % (stats.summary.hit_rate * 100))
	
	print("\n--- Individual Pool Stats ---")
	for pool_name in platform_pools:
		if pool_name != "summary":
			var pool_stats = stats[pool_name]
			var utilization = 0.0
			if pool_stats.total_objects > 0:
				utilization = float(pool_stats.active_objects) / float(pool_stats.total_objects) * 100.0
			print("Pool '", pool_name, "': ", pool_stats.active_objects, "/", pool_stats.total_objects, 
				  " (", "%.1f%%" % utilization, " utilization)")

func cleanup_all_pools():
	for pool_name in platform_pools:
		var pool = platform_pools[pool_name]
		# Simple cleanup - clear the arrays
		pool.available_objects.clear()
		pool.active_objects.clear()
	
	platform_pools.clear()
	print("PlatformPoolManager: Cleaned up all pools")

# Load configuration settings from GameConfig
func _load_config_settings():
	var config = GameConfig.current
	if config:
		enable_pooling = config.enable_object_pooling
		initial_pool_size = config.initial_platform_pool_size
		max_pool_size = config.max_platform_pool_size
		auto_expand_pools = config.auto_expand_pools
		
		print("PlatformPoolManager: Loaded config - Pooling: ", enable_pooling, 
			  ", Initial: ", initial_pool_size, ", Max: ", max_pool_size)